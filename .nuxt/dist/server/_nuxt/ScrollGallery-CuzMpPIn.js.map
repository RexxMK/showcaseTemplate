{"version":3,"file":"ScrollGallery-CuzMpPIn.js","sources":["../../../../components/ImageSlider.vue","../../../../components/ImageGallery.vue","../../../../components/PageHero.vue","../../../../components/ScrollGallery.vue"],"sourcesContent":["<template>\n  <div class=\"c-image-slider\">\n    <!-- MOBIL -->\n    <div v-if=\"isMobile\" class=\"relative\">\n      <div class=\"flex gap-x-[16px] overflow-auto h-auto sliderShadow\">\n        <template v-for=\"(image, index) in mobileImages\" :key=\"index\">\n          <img\n            :src=\"image.src\"\n            :alt=\"image.alt\"\n            class=\"w-[330px] sliderShadow\"\n          />\n        </template>\n      </div>\n    </div>\n\n    <!-- LAPTOP -->\n    <div v-else class=\"flex flex-col gap-y-[97px]\">\n      <!-- Top row slider -->\n      <div\n        class=\"flex gap-x-[68px]\"\n        :style=\"{ transform: `translateX(${topRowTranslate}px)` }\"\n      >\n        <template\n          v-for=\"(image, index) in infiniteTopRowImages\"\n          :key=\"index\"\n          class=\"sliderShadow h-[385px]\"\n        >\n          <img :src=\"image.src\" :alt=\"image.alt\" class=\"w-[650px]\" />\n        </template>\n      </div>\n\n      <!-- Bottom row slider -->\n      <div\n        class=\"flex gap-x-[68px]\"\n        :style=\"{ transform: `translateX(${bottomRowTranslate}px)` }\"\n      >\n        <template\n          v-for=\"(image, index) in infiniteBottomRowImages\"\n          :key=\"index\"\n          class=\"sliderShadow h-[383px]\"\n        >\n          <img :src=\"image.src\" :alt=\"image.alt\" class=\"w-[650px]\" />\n        </template>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nconst props = defineProps({\n  topRowImages: Array,\n  bottomRowImages: Array,\n  mobileImages: Array,\n  caption: String,\n});\n\n// 'ref' bruges til at lave en reaktiv variabel 'isMobile', der som udgangspunkt er falsk.\nconst isMobile = ref(false);\n\n// Funktionen updateIsMobile ser på bredden (clientWidth) af den synlige del af HTML-dokumentet.\n// Hvis bredden er under 768 pixels, betragtes det som en mobilskærm, og 'isMobile' opdateres til sand.\nconst updateIsMobile = () => {\n  isMobile.value = document.documentElement.clientWidth < 768;\n};\n\nonMounted(() => {\n  updateIsMobile(); // Opdaterer ved start, baseret på vinduets bredde\n  window.addEventListener(\"resize\", updateIsMobile); // Lytter efter vinduesændringer\n});\n\n// Styrer billedernes position i slideren\nconst topRowTranslate = ref(0);\nconst bottomRowTranslate = ref(0);\n\n// Funktionen placerer det sidste billede i bottomRowImages arrayet ved starten af viewport\nonMounted(() => {\n  // Den samlede bredde af alle billeder i den nederste slider beregnes ved at gange antallet af billeder med bredden af hvert billede.\n  const totalWidth = props.bottomRowImages.length * 650;\n\n  // Ved at trække 'totalWidth' fra og derefter tilføje halvdelen af viewport bredden, placeres det sidste billede i slideren ved starten af viewport.\n  bottomRowTranslate.value = -totalWidth + window.innerWidth / 2;\n});\n\nlet lastScrollPosition = 0;\n\n// Funktionen registrerer den aktuelle scroll position og sammenligner den med den foregående scroll position.\n// Når man scroller op eller ned på siden opdaterer funktionen positionen for billederne i slideren med en offset på 4px.\n// Resultatet af dette er en glidende effekt for billederne i slideren, når man scroller på siden.\nconst handleScroll = () => {\n  const currentScrollPosition =\n    window.scrollY || document.documentElement.scrollTop;\n\n  if (currentScrollPosition > lastScrollPosition) {\n    // Scroller ned\n    topRowTranslate.value -= 4;\n    bottomRowTranslate.value += 4;\n  } else {\n    // Scroller op\n    topRowTranslate.value += 4;\n    bottomRowTranslate.value -= 4;\n  }\n\n  lastScrollPosition = currentScrollPosition;\n};\n\n// Denne funktion tager et billedearray som input og genererer et nyt array, hvor billederne gentages for at skabe en uendelig scrolleffekt.\nconst getInfiniteImages = (images) => {\n  // Funktionen tjekker, om det billedearray, der sendes til funktionen er tomt.\n  // Hvis det er tomt returneres et tomt array\n  if (!images || images.length === 0) return [];\n\n  // Antallet af gentagelser beregnes ud fra vinduets bredde og bredden af billederne.\n  // 'Math.ceil' sikrer at der altid tages højde for mindst en fuld gentagelse af billederne, selvom der kun er plads til en del af billedet.\n  const repeatCount = Math.ceil(window.innerWidth / 650) + 1;\n\n  // Der oprettes et nyt array af længden 'repeatCount', hvor hvert element i det nye array er en kopi af 'images'.\n  return Array.from({ length: repeatCount }, () => images).flat();\n};\n\nconst infiniteTopRowImages = computed(() =>\n  getInfiniteImages(props.topRowImages)\n);\n\nconst infiniteBottomRowImages = computed(() =>\n  getInfiniteImages(props.bottomRowImages)\n);\n\nonMounted(() => {\n  window.addEventListener(\"scroll\", handleScroll);\n});\n\nonUnmounted(() => {\n  window.removeEventListener(\"scroll\", handleScroll);\n});\n</script>\n","<template>\n  <div class=\"c-image-gallery\">\n    <div>\n      <!-- MOBIL -->\n      <div v-if=\"isMobile\" class=\"flex justify-center\">\n        <div class=\"grid gap-[49px]\">\n          <div\n            v-for=\"(image, index) in mobileImages.slice(0, sliceAmount)\"\n            :key=\"index\"\n          >\n            <img :src=\"image.src\" :alt=\"image.alt\" class=\"w-[330px]\" />\n          </div>\n        </div>\n      </div>\n\n      <!-- LAPTOP -->\n      <div v-else class=\"flex justify-center\">\n        <div class=\"grid grid-cols-3 gap-[68px]\">\n          <div\n            v-for=\"(image, index) in laptopImages.slice(0, sliceAmount)\"\n            :key=\"index\"\n          >\n            <img :src=\"image.src\" :alt=\"image.alt\" class=\"w-[430px]\" />\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- KNAP -->\n    <div class=\"flex justify-center pt-[58px]\">\n      <button\n        v-if=\"cta\"\n        class=\"caption-lg w-[213px] h[48px] rounded-50 cursor-pointer bg-detail text-detail-text\"\n        @click=\"toggleImages\"\n      >\n        {{ buttonLabel }}\n      </button>\n    </div>\n  </div>\n</template>\n\n<script setup>\n// Selvom jeg bruger de samme billeder til galleriet på både mobil og laptop i After August casen,\n// vælger jeg at definere både mobileImages og laptopImages, da man så har muligheden for at bruge forskellige billeder på mobil og laptop.\nconst props = defineProps({\n  mobileImages: Array,\n  laptopImages: Array,\n  cta: Object,\n  sliceAmount: {\n    type: Number,\n    default: 3,\n  },\n});\n\nconst sliceAmount = ref(props.sliceAmount);\n\n// 'ref' bruges til at lave en reaktiv variabel 'isMobile', der som udgangspunkt er falsk.\nconst isMobile = ref(false);\n\n// Funktionen updateIsMobile ser på bredden (clientWidth) af den synlige del af HTML-dokumentet.\n// Hvis bredden er under 768 pixels, betragtes det som en mobilskærm, og 'isMobile' opdateres til sand.\nconst updateIsMobile = () => {\n  isMobile.value = document.documentElement.clientWidth < 768;\n};\n\nonMounted(() => {\n  updateIsMobile(); // Opdaterer ved start, baseret på vinduets bredde\n  window.addEventListener(\"resize\", updateIsMobile); // Lytter efter vinduesændringer\n});\n\nconst isAllImagesVisible = ref(false);\n\n// Funktionen ændrer antallet af viste billeder, og skifter mellem at vise alle billeder eller kun et begrænset antal billeder, når der trykkes på knappen.\nconst toggleImages = () => {\n  if (isAllImagesVisible.value) {\n    sliceAmount.value = props.sliceAmount;\n  } else {\n    sliceAmount.value = isMobile.value\n      ? props.mobileImages.length\n      : props.laptopImages.length;\n  }\n  isAllImagesVisible.value = !isAllImagesVisible.value;\n};\n\n// Det resterende antal billeder og det viste antal billeder beregnes afhængigt af skærmstørrelsen og det aktuelle antal viste billeder ('sliceAmount').\n// 'Math.max(0, ...)' bruges til at sikre, at værdien der returneres altid er mindst 0.\n// Det forhindrer også negative værdier, hvis 'sliceAmount' er større end antallet af billeder.\nconst remainingAmount = computed(() => {\n  if (isMobile.value) {\n    return Math.max(0, props.mobileImages.length - sliceAmount.value);\n  } else {\n    return Math.max(0, props.laptopImages.length - sliceAmount.value);\n  }\n});\n\nconst shownAmount = computed(() => {\n  if (isMobile.value) {\n    return Math.max(0, props.mobileImages.length - props.sliceAmount);\n  } else {\n    return Math.max(0, props.laptopImages.length - props.sliceAmount);\n  }\n});\n\n// Jeg laver et label til knappen baseret på om alle billeder er synlige eller ej, samt hvor mange billeder der er tilbage eller vist.\nconst buttonLabel = computed(() => {\n  return isAllImagesVisible.value\n    ? props.cta.isActive + \" \" + shownAmount.value\n    : props.cta.name + \" \" + remainingAmount.value;\n});\n</script>\n","<template>\n  <div class=\"c-page-hero text-secondary\">\n    <div class=\"c-page-hero_award flex flex-col items-center mt-[30px]\">\n      <img\n        v-if=\"award.image\"\n        :src=\"award.image.src\"\n        :alt=\"award.image.alt\"\n        class=\"w-[100px] shadow-none\"\n      />\n\n      <div\n        v-if=\"award.name\"\n        class=\"max-w-21ch text-center pt-[23px] caption-sm\"\n      >\n        {{ award.name }}\n      </div>\n    </div>\n    <div class=\"c-page-hero_content flex flex-col items-center\">\n      <!-- MOBIL -->\n      <div v-if=\"isMobile\" class=\"flex flex-col items-center pt-[99px]\">\n        <div v-if=\"title\" class=\"header-sm\">{{ title }}</div>\n        <div class=\"flex justify-center\">\n          <div\n            v-if=\"teaser\"\n            class=\"body-sm text-center pt-[36px] pb-[105px]\"\n            :class=\"teaserMaxWidth\"\n          >\n            {{ teaser }}\n          </div>\n        </div>\n      </div>\n\n      <!-- LAPTOP -->\n      <div v-else class=\"pt-[206px]\">\n        <div v-if=\"title\" class=\"header-lg\">{{ title }}</div>\n        <div class=\"flex justify-center\">\n          <div\n            v-if=\"teaser\"\n            class=\"body-lg text-center pt-[18px] pb-[62px]\"\n            :class=\"teaserMaxWidth\"\n          >\n            {{ teaser }}\n          </div>\n        </div>\n      </div>\n\n      <!-- KNAP -->\n      <button\n        v-if=\"cta\"\n        class=\"w-[213px] h-[48px] rounded-50 cursor-pointer caption-lg bg-detail text-detail-text\"\n        @click=\"openUrlInNewTab\"\n      >\n        {{ cta.name }}\n        <span class=\"w-[12px] absolute ml-[14px]\">\n          <svg\n            viewBox=\"0 0 12 13\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n          >\n            <path\n              d=\"M0.166504 12.3337V0.666992H5.74248V1.6964H1.19592V11.3042H10.8038V6.75768H11.8332V12.3337H0.166504ZM4.43856 8.78219L3.71797 8.0616L10.0832 1.6964H7.37239V0.666992H11.8332V5.12778H10.8038V2.41699L4.43856 8.78219Z\"\n              fill=\"currentColor\"\n            />\n          </svg>\n        </span>\n      </button>\n    </div>\n  </div>\n</template>\n\n<script setup>\nconst props = defineProps({\n  title: String,\n  teaser: String,\n  award: Object,\n  cta: Object,\n  teaserMaxWidth: {\n    type: String,\n    default: \"max-w-45ch\", // Standard max-width\n  },\n});\n\n// 'ref' bruges til at lave en reaktiv variabel 'isMobile', der som udgangspunkt er falsk.\nconst isMobile = ref(false);\n\n// Funktionen updateIsMobile ser på bredden (clientWidth) af den synlige del af HTML-dokumentet.\n// Hvis bredden er under 768 pixels, betragtes det som en mobilskærm, og 'isMobile' opdateres til sand.\nconst updateIsMobile = () => {\n  isMobile.value = document.documentElement.clientWidth < 768;\n};\n\nonMounted(() => {\n  updateIsMobile(); // Opdaterer ved start, baseret på vinduets bredde\n  window.addEventListener(\"resize\", updateIsMobile); // Lytter efter vinduesændringer\n});\n\nconst url = ref(props.cta.url);\n\nconst openUrlInNewTab = () => {\n  const url = typeof props.cta === \"object\" ? props.cta.url : null; // Man får kun URL'en, hvis cta er et objekt\n  if (url) {\n    window.open(url, \"_blank\"); // Åbner URL'en i en ny fane\n  }\n};\n</script>\n","<template>\n  <div class=\"c-scroll-gallery\">\n    <!-- MOBIL -->\n    <div v-if=\"isMobile\">\n      <div class=\"flex flex-col items-center gap-y-[84px]\">\n        <div v-for=\"(image, index) in mobileImages\" :key=\"index\">\n          <img :src=\"image.src\" :alt=\"image.alt\" class=\"w-[330px]\" />\n        </div>\n      </div>\n    </div>\n\n    <!-- LAPTOP -->\n    <div v-else class=\"flex justify-center gap-x-[68px]\">\n      <div\n        ref=\"leftColumn\"\n        class=\"flex flex-col gap-y-[97px] h-full sticky top-0\"\n      >\n        <div v-for=\"(image, index) in mobileImages\" :key=\"index\">\n          <img :src=\"image.src\" :alt=\"image.alt\" class=\"w-[291px]\" />\n        </div>\n      </div>\n      <div\n        ref=\"rightColumn\"\n        class=\"flex flex-col gap-y-[97px] h-full sticky top-0\"\n      >\n        <div v-for=\"(image, index) in laptopImages\" :key=\"index\">\n          <img :src=\"image.src\" :alt=\"image.alt\" class=\"w-[1019px]\" />\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\ndefineProps({\n  mobileImages: Array,\n  laptopImages: Array,\n});\n\n// 'ref' bruges til at lave en reaktiv variabel 'isMobile', der som udgangspunkt er falsk.\nconst isMobile = ref(false);\n\n// Funktionen updateIsMobile ser på bredden (clientWidth) af den synlige del af HTML-dokumentet.\n// Hvis bredden er under 768 pixels, betragtes det som en mobilskærm, og 'isMobile' opdateres til sand.\nconst updateIsMobile = () => {\n  isMobile.value = document.documentElement.clientWidth < 768;\n};\n\nonMounted(() => {\n  updateIsMobile(); // Opdaterer ved start, baseret på vinduets bredde\n  window.addEventListener(\"resize\", updateIsMobile); // Lytter efter vinduesændringer\n});\n\n// Nedenstående kode er del af en bedre og mere glat løsning til scroll i kolonnerne\n\n// const leftColumn = ref(null);\n// const rightColumn = ref(null);\n\n// onMounted(() => {\n//   if (leftColumn.value && rightColumn.value) {\n//     setTimeout(() => {\n//       const leftColumnHeight = leftColumn.value.offsetHeight;\n//       const rightColumnHeight = rightColumn.value.offsetHeight;\n\n//       console.log(\"Left column height:\", leftColumnHeight);\n//       console.log(\"Right column height:\", rightColumnHeight);\n//     }, 500);\n//   } else {\n//     console.error(\"One or both columns are not found.\");\n//   }\n// });\n</script>\n"],"names":[],"mappings":";;;;;;;;;;;;AAiDA,UAAM,QAAQ;AAQR,UAAA,WAAW,IAAI,KAAK;AAcpB,UAAA,kBAAkB,IAAI,CAAC;AACvB,UAAA,qBAAqB,IAAI,CAAC;AAWhC,QAAI,qBAAqB;AAKzB,UAAM,eAAe,MAAM;AACzB,YAAM,wBACJ,SAAO,WAAW,SAAS,gBAAgB;AAE7C,UAAI,wBAAwB,oBAAoB;AAE9C,wBAAgB,SAAS;AACzB,2BAAmB,SAAS;AAAA,MAAA,OACvB;AAEL,wBAAgB,SAAS;AACzB,2BAAmB,SAAS;AAAA,MAC9B;AAEqB,2BAAA;AAAA,IAAA;AAIjB,UAAA,oBAAoB,CAAC,WAAW;AAGhC,UAAA,CAAC,UAAU,OAAO,WAAW;AAAG,eAAO;AAI3C,YAAM,cAAc,KAAK,KAAY,SAAA,aAAa,GAAG,IAAI;AAGlD,aAAA,MAAM,KAAK,EAAE,QAAQ,eAAe,MAAM,MAAM,EAAE;IAAK;AAGhE,UAAM,uBAAuB;AAAA,MAAS,MACpC,kBAAkB,MAAM,YAAY;AAAA,IAAA;AAGtC,UAAM,0BAA0B;AAAA,MAAS,MACvC,kBAAkB,MAAM,eAAe;AAAA,IAAA;AAOzC,gBAAY,MAAM;AACT,MAAA,SAAA,oBAAoB,UAAU,YAAY;AAAA,IAAA,CAClD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzFD,UAAM,QAAQ;AAUR,UAAA,cAAc,IAAI,MAAM,WAAW;AAGnC,UAAA,WAAW,IAAI,KAAK;AAapB,UAAA,qBAAqB,IAAI,KAAK;AAiB9B,UAAA,kBAAkB,SAAS,MAAM;AACrC,UAAI,SAAS,OAAO;AAClB,eAAO,KAAK,IAAI,GAAG,MAAM,aAAa,SAAS,YAAY,KAAK;AAAA,MAAA,OAC3D;AACL,eAAO,KAAK,IAAI,GAAG,MAAM,aAAa,SAAS,YAAY,KAAK;AAAA,MAClE;AAAA,IAAA,CACD;AAEK,UAAA,cAAc,SAAS,MAAM;AACjC,UAAI,SAAS,OAAO;AAClB,eAAO,KAAK,IAAI,GAAG,MAAM,aAAa,SAAS,MAAM,WAAW;AAAA,MAAA,OAC3D;AACL,eAAO,KAAK,IAAI,GAAG,MAAM,aAAa,SAAS,MAAM,WAAW;AAAA,MAClE;AAAA,IAAA,CACD;AAGK,UAAA,cAAc,SAAS,MAAM;AACjC,aAAO,mBAAmB,QACtB,MAAM,IAAI,WAAW,MAAM,YAAY,QACvC,MAAM,IAAI,OAAO,MAAM,gBAAgB;AAAA,IAAA,CAC5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrCD,UAAM,QAAQ;AAYR,UAAA,WAAW,IAAI,KAAK;AAad,QAAI,MAAM,IAAI,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxDvB,UAAA,WAAW,IAAI,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}